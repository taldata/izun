#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from flask import Flask, render_template, request, jsonify, session
from datetime import datetime, date, timedelta, time
import json
import os
from flask.json.provider import DefaultJSONProvider

# Import services from services_init (singleton instances)
from services_init import (
    db, ad_service, auto_scheduler, auto_schedule_service, audit_logger,
    constraints_service, committee_types_service, committee_recommendation_service,
    auth_manager, calendar_service, calendar_sync_scheduler
)

from db import cleanup_db

# Import blueprints
from routes import auth_bp, api_bp, admin_bp, committee_bp, event_bp, main_bp, migration_bp

app = Flask(__name__)

# Security Configuration
# Fallback to dev key if not set (user notification in plan)
app.secret_key = os.getenv('FLASK_SECRET_KEY', 'committee_management_secret_key_2025_azure_oauth_enabled')

# Custom JSON Provider to handle time objects
class CustomJSONProvider(DefaultJSONProvider):
    def default(self, obj):
        if isinstance(obj, time):
            return obj.strftime('%H:%M')
        if isinstance(obj, (date, datetime)):
            return obj.isoformat()
        return super().default(obj)

app.json = CustomJSONProvider(app)

# Session configuration
session_cookie_secure = os.getenv('SESSION_COOKIE_SECURE', 'true').lower() == 'true'
session_lifetime_hours = int(os.getenv('SESSION_LIFETIME_HOURS', '8'))

app.config['SESSION_COOKIE_SECURE'] = session_cookie_secure
app.config['SESSION_COOKIE_HTTPONLY'] = True
app.config['SESSION_COOKIE_SAMESITE'] = None  # Allow cross-site for OAuth redirects
app.config['PERMANENT_SESSION_LIFETIME'] = timedelta(hours=session_lifetime_hours)
app.config['SESSION_REFRESH_EACH_REQUEST'] = True

# Register Blueprints
app.register_blueprint(main_bp)
app.register_blueprint(auth_bp) # Routes like /login, /logout
app.register_blueprint(api_bp)
app.register_blueprint(admin_bp) # Routes like /hativot, /maslulim
app.register_blueprint(committee_bp)
app.register_blueprint(event_bp)
app.register_blueprint(migration_bp)

# Start calendar sync scheduler
if not app.debug or os.environ.get('WERKZEUG_RUN_MAIN') == 'true':
    try:
        if not calendar_sync_scheduler.is_running:
            calendar_sync_scheduler.start()
            app.logger.info("Calendar sync scheduler started")
    except Exception as e:
        app.logger.error(f"Failed to start scheduler: {e}")

# Template filters
@app.template_filter('format_datetime')
def format_datetime_filter(value):
    """Format datetime to display without seconds"""
    if value is None:
        return ''
    if isinstance(value, str):
        try:
            # Parse ISO format datetime string
            value = datetime.fromisoformat(value.replace('+00:00', '').replace('Z', ''))
        except:
            return value
    if isinstance(value, datetime):
        return value.strftime('%Y-%m-%d %H:%M')
    return str(value)

@app.template_filter('format_date')
def format_date_filter(value):
    """Format date to DD/MM/YYYY"""
    if value is None:
        return ''
    if isinstance(value, str):
        try:
            # Try to parse the string as a date
            from datetime import date as date_type
            for fmt in ('%Y-%m-%d', '%d/%m/%Y'):
                try:
                    value = datetime.strptime(value, fmt).date()
                    break
                except ValueError:
                    continue
        except:
            return value
    # Handle both date and datetime objects
    if hasattr(value, 'strftime'):
        return value.strftime('%d/%m/%Y')
    return str(value)

# Mobile device detection middleware
def is_mobile_device():
    """Detect if the request is from a mobile device"""
    user_agent = request.headers.get('User-Agent', '').lower()
    mobile_keywords = ['android', 'webos', 'iphone', 'ipad', 'ipod', 'blackberry', 'windows phone', 'mobile']
    return any(keyword in user_agent for keyword in mobile_keywords)

@app.before_request
def check_mobile_access():
    """Block mobile device access (optional - can be disabled)"""
    # Skip check for static files and API endpoints
    if request.path.startswith('/static/') or request.path.startswith('/api/'):
        return None
    
    # Uncomment the following lines to enable server-side mobile blocking
    # if is_mobile_device():
    #     return render_template('mobile_blocked.html'), 403
    
    return None

@app.teardown_appcontext
def cleanup_sqlalchemy_session(exception=None):
    """Clean up SQLAlchemy session at end of each request."""
    cleanup_db()

# Error handlers
@app.errorhandler(500)
def internal_server_error(e):
    """Handle internal server errors gracefully"""
    app.logger.error(f"Internal Server Error: {e}", exc_info=True)
    return render_template('errors/auth_error.html',
        title='שגיאת שרת פנימית',
        message='אירעה שגיאה פנימית בשרת. אנא נסה שוב מאוחר יותר.',
        details=str(e) if app.debug else None,
        show_retry=True,
        current_user=None), 500

@app.errorhandler(404)
def not_found_error(e):
    """Handle 404 errors gracefully"""
    return render_template('errors/auth_error.html',
        title='דף לא נמצא',
        message='הדף שביקשת לא נמצא.',
        show_retry=True,
        current_user=None), 404

if __name__ == '__main__':
    port = int(os.environ.get('PORT', 5001))
    debug = os.environ.get('FLASK_ENV') != 'production'
    app.run(debug=debug, host='0.0.0.0', port=port)
